name: Parkfolio Collector

on:
  workflow_dispatch:
    inputs:
      shard_total:
        description: 'Override shard count for this manual run'
        required: false
        default: ''

permissions:
  contents: read

concurrency:
  group: parkfolio-cron
  cancel-in-progress: false

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      shard_total: ${{ steps.matrix.outputs.shard_total }}
      shard_indexes: ${{ steps.matrix.outputs.shard_indexes }}
      tick_bucket: ${{ steps.tick.outputs.tick_bucket }}
    steps:
      - name: Resolve tick bucket
        id: tick
        run: |
          set -euo pipefail
          now_epoch="$(date -u +%s)"
          bucket_epoch="$(( now_epoch - (now_epoch % 300) ))"
          tick_bucket="$(date -u -d "@$bucket_epoch" +"%Y-%m-%dT%H:%M:00.000Z")"
          echo "tick_bucket=$tick_bucket" >> "$GITHUB_OUTPUT"
          echo "Using tick bucket: $tick_bucket"

      - name: Resolve shard matrix
        id: matrix
        env:
          INPUT_SHARD_TOTAL: ${{ github.event.inputs.shard_total }}
          DEFAULT_SHARD_TOTAL: ${{ vars.COLLECTOR_SHARD_TOTAL }}
        run: |
          set -euo pipefail
          shard_total="${INPUT_SHARD_TOTAL:-${DEFAULT_SHARD_TOTAL:-6}}"

          if ! [[ "$shard_total" =~ ^[0-9]+$ ]]; then
            echo "Invalid shard_total: $shard_total" >&2
            exit 1
          fi

          if [ "$shard_total" -lt 1 ] || [ "$shard_total" -gt 32 ]; then
            echo "shard_total must be between 1 and 32 (got $shard_total)" >&2
            exit 1
          fi

          shard_indexes="$(node -e 'const n=Number(process.argv[1]); console.log(JSON.stringify(Array.from({length:n}, (_,i)=>i)))' "$shard_total")"

          echo "shard_total=$shard_total" >> "$GITHUB_OUTPUT"
          echo "shard_indexes=$shard_indexes" >> "$GITHUB_OUTPUT"
          echo "Shard indexes: $shard_indexes"

      - name: Health check (quick)
        env:
          BASE_URL: ${{ secrets.BASE_URL || secrets.VERCEL_URL }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
        run: |
          set -euo pipefail

          if [ -z "${CRON_SECRET:-}" ]; then
            echo "CRON_SECRET is not configured." >&2
            exit 1
          fi

          BASE_URL="${BASE_URL:-https://parkfolio.vercel.app}"
          BASE_URL="${BASE_URL%/}"

          quick_url="$BASE_URL/api/cron/collect-queue-times?secret=$CRON_SECRET&quick=true"
          echo "Health check: $quick_url"
          healthy="false"
          for attempt in 1 2 3; do
            if curl -fsSL --connect-timeout 10 --max-time 20 "$quick_url" >/dev/null; then
              echo "Health check OK"
              healthy="true"
              break
            fi

            echo "Health check failed on attempt $attempt/3"
            [ "$attempt" -eq 3 ] && break
            sleep 3
          done

          if [ "$healthy" != "true" ]; then
            echo "Quick health check could not be confirmed; proceeding to shard run for definitive validation."
          fi

  collect:
    needs: prepare
    runs-on: ubuntu-latest
    timeout-minutes: 12
    strategy:
      fail-fast: false
      # Keep shard fan-out conservative so each function invocation has
      # enough headroom under platform timeout limits.
      max-parallel: 2
      matrix:
        shard_index: ${{ fromJson(needs.prepare.outputs.shard_indexes) }}
    steps:
      - name: Run shard collection
        env:
          BASE_URL: ${{ secrets.BASE_URL || secrets.VERCEL_URL }}
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
          SHARD_INDEX: ${{ matrix.shard_index }}
          SHARD_TOTAL: ${{ needs.prepare.outputs.shard_total }}
          TICK_BUCKET: ${{ needs.prepare.outputs.tick_bucket }}
        run: |
          set -euo pipefail

          if [ -z "${CRON_SECRET:-}" ]; then
            echo "CRON_SECRET is not configured." >&2
            exit 1
          fi

          BASE_URL="${BASE_URL:-https://parkfolio.vercel.app}"
          BASE_URL="${BASE_URL%/}"

          collector_url="$BASE_URL/api/cron/collect-queue-times?secret=$CRON_SECRET&shard_index=$SHARD_INDEX&shard_total=$SHARD_TOTAL&tick_bucket=$TICK_BUCKET"

          echo "Running shard ${SHARD_INDEX}/${SHARD_TOTAL} for tick $TICK_BUCKET"

          for attempt in 1 2 3; do
            TMP_BODY="$(mktemp)"
            HTTP_STATUS="$(curl -sS --connect-timeout 15 --max-time 90 -o "$TMP_BODY" -w "%{http_code}" "$collector_url" || true)"
            if ! [[ "$HTTP_STATUS" =~ ^[0-9]{3}$ ]]; then
              HTTP_STATUS="000"
            fi
            RESP="$(cat "$TMP_BODY")"
            rm -f "$TMP_BODY"

            if [ "$HTTP_STATUS" = "000" ]; then
              echo "Network error on attempt $attempt/3"
              if [ "$attempt" -lt 3 ]; then
                sleep 3
                continue
              fi
              exit 1
            fi

            echo "Collector HTTP status: $HTTP_STATUS"
            echo "$RESP"

            if [ "$HTTP_STATUS" -lt 200 ] || [ "$HTTP_STATUS" -ge 300 ]; then
              # Retry only once for transient server-side responses.
              if [ "$HTTP_STATUS" -ge 500 ] && [ "$attempt" -lt 3 ]; then
                echo "Server error on attempt $attempt/3, retrying..."
                sleep 3
                continue
              fi
              if [ "$HTTP_STATUS" -lt 500 ]; then
                echo "Collector returned non-2xx response ($HTTP_STATUS)" >&2
                exit 1
              fi
              echo "Collector returned HTTP $HTTP_STATUS; evaluating payload for recoverable conditions."
            fi

            if ! printf '%s' "$RESP" | jq -e . >/dev/null 2>&1; then
              echo "Collector response is not valid JSON" >&2
              exit 1
            fi

            contract_version="$(printf '%s' "$RESP" | jq -r '.contractVersion // empty')"
            success="$(printf '%s' "$RESP" | jq -r '.success // false')"
            critical_failure="$(printf '%s' "$RESP" | jq -r '.criticalFailure // false')"
            duplicate_skipped="$(printf '%s' "$RESP" | jq -r '.duplicateSkipped // false')"
            duplicate_of_status="$(printf '%s' "$RESP" | jq -r '.duplicate_of_status // empty')"
            run_id="$(printf '%s' "$RESP" | jq -r '.runId // "unknown"')"
            noncritical_insert_warnings_only="$(printf '%s' "$RESP" | jq -r '
              (.stats.errors // []) as $errs
              | if ($errs | length) == 0 then
                  "false"
                else
                  ($errs | all(
                    . == "Supabase wait-time insert counter is zero after processing parks"
                    or . == "Turso wait-time insert counter is zero after processing parks"
                    or . == "Supabase weather insert counter is zero after processing weather-eligible parks"
                    or . == "Turso weather insert counter is zero after processing weather-eligible parks"
                  )) | tostring
                end
            ')"

            response_tick="$(printf '%s' "$RESP" | jq -r '.tick_bucket // empty')"
            response_shard_index="$(printf '%s' "$RESP" | jq -r '.shard_index // empty')"
            response_shard_total="$(printf '%s' "$RESP" | jq -r '.shard_total // empty')"
            coverage_expected="$(printf '%s' "$RESP" | jq -r '.coverage_expected_parks // empty')"
            coverage_processed="$(printf '%s' "$RESP" | jq -r '.coverage_processed_parks // empty')"
            timeout_rate="$(printf '%s' "$RESP" | jq -r '.stats.timeoutRate // empty')"

            if [ "$HTTP_STATUS" = "503" ] \
              && [ "$success" != "true" ] \
              && [ "$critical_failure" = "true" ] \
              && [ "$noncritical_insert_warnings_only" = "true" ]; then
              echo "Detected legacy insert-counter 503 for shard ${SHARD_INDEX}/${SHARD_TOTAL}; treating as non-critical while rollout completes."
              success="true"
              critical_failure="false"
            fi

            if [ "$contract_version" != "collect-queue-times/v1" ]; then
              echo "Collector contract mismatch (expected collect-queue-times/v1, got ${contract_version:-missing})" >&2
              exit 1
            fi

            for field_value in \
              "tick_bucket:$response_tick" \
              "shard_index:$response_shard_index" \
              "shard_total:$response_shard_total" \
              "coverage_expected_parks:$coverage_expected" \
              "coverage_processed_parks:$coverage_processed" \
              "timeoutRate:$timeout_rate"
            do
              field="${field_value%%:*}"
              value="${field_value#*:}"
              if [ -z "$value" ] || [ "$value" = "null" ]; then
                echo "Collector response missing required field: $field" >&2
                exit 1
              fi
            done

            if [ "$response_tick" != "$TICK_BUCKET" ]; then
              echo "Tick bucket mismatch (expected $TICK_BUCKET, got $response_tick)" >&2
              exit 1
            fi

            if [ "$response_shard_index" != "$SHARD_INDEX" ]; then
              echo "Shard index mismatch (expected $SHARD_INDEX, got $response_shard_index)" >&2
              exit 1
            fi

            if [ "$response_shard_total" != "$SHARD_TOTAL" ]; then
              echo "Shard total mismatch (expected $SHARD_TOTAL, got $response_shard_total)" >&2
              exit 1
            fi

            if [ "$duplicate_skipped" = "true" ]; then
              if [ "$duplicate_of_status" != "completed" ]; then
                echo "Duplicate skip was returned for non-completed status (${duplicate_of_status:-missing}); treating as failure." >&2
                exit 1
              fi
              echo "Shard run already processed for tick $TICK_BUCKET (runId=$run_id); skipping as idempotent duplicate."
              exit 0
            fi

            if [ "$success" != "true" ]; then
              echo "Collector reported success=false (runId=$run_id)" >&2
              exit 1
            fi

            if [ "$critical_failure" = "true" ]; then
              echo "Collector flagged criticalFailure=true (runId=$run_id)" >&2
              exit 1
            fi

            if awk "BEGIN {exit !($timeout_rate >= 0.2)}"; then
              echo "Critical: timeout threshold breached for shard ${SHARD_INDEX}/${SHARD_TOTAL} (timeoutRate=$timeout_rate)" >&2
              exit 1
            fi

            if [ "$coverage_processed" -lt "$coverage_expected" ]; then
              echo "Shard coverage incomplete for ${SHARD_INDEX}/${SHARD_TOTAL}: processed=$coverage_processed expected=$coverage_expected" >&2
              exit 1
            fi

            echo "Validated shard ${SHARD_INDEX}/${SHARD_TOTAL} runId=$run_id tick=$response_tick coverage=${coverage_processed}/${coverage_expected} timeoutRate=$timeout_rate"
            exit 0
          done

          echo "Failed to run shard ${SHARD_INDEX}/${SHARD_TOTAL} after retries" >&2
          exit 1
